[{"title":"hexo+github搭建自己的博客","date":"2017-04-08T07:08:32.000Z","path":"2017/04/08/hexo+github搭建自己的博客/","text":"之前很早就想用hexo弄一个自己独立的博客了，在博客园也写了很多的博客,不过不喜欢博客园的风格。不过今天，终于折腾成功了，用hexo搭建了一个在github写的博客，开心，后面会将自己以前的博客慢慢迁移过来。 前期准备工作 安装hexo npm install -g hexo 创建一个文件夹，如：myBog，cd到myBog里执行hexo init命令 执行hexo generate （hexo g 也可以） 执行hexo server hexo写博客的步骤新建一篇博客: 方法1： 1hexo new &quot;文章标题&quot; 方法2：在本地博客文件夹source-&gt;_post文件夹下看到我们新建的markdown文件 两者的效果是一样的 进行本地发布 执行命令 hexo server 浏览器打开：http://localhost:4000/ 部署到线上，执行三个命令 hexo clean hexo generate 也可以 hexo g hexo deploy 一些常用命令hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help #查看帮助hexo version #查看Hexo的版本 小tips 问：如何让文章想只显示一部分和一个 阅读全文 的按钮？答：在文章中加一个 &lt;!--more--&gt; ， &lt;!--more--&gt; 后面的内容就不会显示出来了。 问：本地部署成功了，也能预览效果，但使用 username.github.io 访问，出现 404 .答：首先确认 hexo d 命令执行是否报错，如果没有报错，再查看一下你的 github 的 username.github.io 仓库，你的博客是否已经成功提交了，你的 github 邮箱也要通过验证才行。 如何更换主题分为以下个步骤： 选择主题:哪里选呢，可以在这里官方主题 安装主题： 将主题下载或者clone到你的站点目录的 themes 目录中，比如我要安装yilia主题，那么将改文件夹复制到themes中，即为 themes/yilia 打开 站点配置文件_config.yml，找到 theme 字段，并将其值更改为 yilia(你要安装的主题的文件夹名字) 。 验证主题是否启用: 运行 hexo s --debug ，并访问 http://localhost:4000 ，确保站点正确运行。 部署和发布到文章的步骤一样 头像设置在主题文件夹下的_config.yml中：avatar: https://avatars1.githubusercontent.com/u/32269?v=3&amp;s=460.比如我的是themes/yilia/_config.yml由于我用的是yilia主题，或者直接修改layout/_partial/left-col.ejs的第六行和第八行为：12&lt;img src=\"&lt;%=theme.avatar%&gt;\" class=\"js-avatar show\"&gt;&lt;img src=\"&lt;%=theme.avatar%&gt;\" class=\"js-avatar show\" style=\"width: 100%;height: 100%;opacity: 1;\"&gt; 添加阅读量计划使用 Lean Cloud 可以参考 这里 添加评论模块可以参考这篇文章：评论模块本博客中，因为多说已经不再维护了，友言不支持https，所以暂时没弄好评论模块,家里的网络访问不了disqus。所以评论模块待定，晚点再弄","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"}]},{"title":"git常用命令总结","date":"2017-03-31T07:50:00.000Z","path":"2017/03/31/git常用命令总结/","text":"平时要用一些命令老是去网上找还挺麻烦的，所以总结起来，方便以后自己的查阅 正常的开发流程命令 首先进入项目的主分支 Fork一份工程，当做自己的项目管理分支&ensp;&ensp;&ensp;Fork的作用:&ensp;&ensp;&ensp;相当于你在原项目的主分支上又建立了一个分支，你可以在该分支上任意修改，如果想将你的修改合并到原项目中时，可以pull request，这样原项目的作者就可以将你修改的东西合并到原项目的主分支上去，这样你就为开源项目贡献了代码，开源项目就会在大家共同的努力下不断壮大和完善。 在电脑上创建一个文件夹，先Clone一份自己工程的项目分支(xxx屏蔽公司信息) 1Git clone git@xxxx.gitlab.com:xxxxxx/SELand_Vertu 进入项目的二级目录进入git客户端，确认要pull分支 git branch 看看当前的分支 git checkout -b develop 切换到develop分支，因为我要pull拉去develop分支上的项目 然后在将自己的项目分支同步项目主分支（我们项目分支为develop分支） git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop 每次提交代码时候，需要先同步项目主分支代码 git status 是哪些文件有所修改 git diff 可以查询所修改的代码 git add -A 增加自己所做的修改 git commit -a 提交所有修改的代码 ，加注释是这样 git commit -a -m &quot;这里是注释的内容&quot; git push origin develop 提交代码,这里的提交只是提交到了项目的develop分支上面，还没提交到master上面 若代码有冲突，可以这样解决 git pull git@xxx.gitlab.com:xxx/SELand_Vertu develop 先同步一下会出现以上的错误 pull会使用git merge导致冲突，需要将冲突的文件resolve掉 git add -u, 在项目中看看哪些代码是对方改的，哪些代码是自己修改的，在合并成一份最新的代码 git commit 之后才能成功添加修改 添加文件到暂缓区： git add -A .一次添加所有改变的文件 git add xx将xx文件添加到暂存区 git add . 添加新文件和编辑过的文件不包括删除的文件 git add -u 添加编辑或者删除的文件，不包括新添加的文件。 commit文件 git commit -m &quot;这里是注释&quot; 提交的是暂存区里面的内容，也就是 Changes to be committed 中的文件。 git commit -a -m &quot;这里是注释&quot; 除了将暂存区里的文件提交外，还提交 Changes bu not updated 中的文件。 git commit --amend有时候我们会发现有几个文件漏了提交或者想修改一下提交信息，又或者忘记使用 -a 选项导致一些文件没有被提交，我们希望对上一次提交进行修改，或者说取消上一次提交，这时候我们需要使用 –amend 选项。 git commit --amend -a用来当我们发现在提交时忘记使用 -a 选项，导致 Changes bu not updated 中的内容没有被提交撤销修改 1.撤销commit方法1:&ensp;&ensp;执行git log查看 commit日志，然后git reset --hard commit_idcommit_id是控制台上的hash值方法2:&ensp;&ensp;git reset –hard HEAD^,如果是上上一个版本git reset –hard HEAD^^,如果是上一百个版本git reset –hard HEAD~100;方法3:&ensp;&ensp;git checkout —-文件名 撤销对某个文件的修改,例：git checkout —-readme.txt；&ensp;&ensp;git checkout -- .撤销对所有文件的修改 ！！注意： 撤销之后，由于本地版本低于线上版本，想要提交代码，只能强行提交，覆盖线上，可以使用下面的命令：git push -f origin 分支名 2.恢复到某一版本现在我又发觉我最新的版本是没错的，我不想撤销了，我要回到最新版本，两步:git reflog查看历史版本；git reset –hard 版本号 3.撤销add&ensp;&ensp;git reset head &lt;文件名&gt; 撤销对某个文件的add命令&ensp;&ensp;git reset head . 撤销所有文件的add命令 创建与合并分支命令如下： 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout –b name 合并某分支到当前分支：git merge name 删除分支：git branch –d name git常用命令 创建一个空目录 XX指目录名mkdir XX 显示当前目录的路径pwd 把当前的目录变成可以管理的git仓库，生成隐藏.git文件git init 把xx文件添加到暂存区去git add XX 提交文件 –m 后面的是注释git commit –m &quot;XX&quot; 查看仓库状态 git status 查看XX文件修改了那些内容 git diff XX 查看历史记录 git log 回退到上一个版本 git reset –hard HEAD^ 或者 git reset –hard HEAD~如果想回退到100个版本，使用git reset –hard HEAD~100 查看XX文件内容 cat XX 查看历史记录的版本号id git reflog 把XX文件在工作区的修改全部撤销 git checkout --XX 删除XX文件 git rm XX 关联一个远程库 git remote add origin https://github.com/xx 把当前master分支推送到远程库 git push –u(第一次要用-u 以后不需要) origin master 从远程库中克隆 git clone https://github.com/xx 创建dev分支 并切换到dev分支上 git checkout –b dev 查看当前所有的分支 git branch 切换回master分支 git checkout master 在当前的分支上合并dev分支 git merge dev 删除dev分支 git branch –d dev 创建分支 git branch name 把当前的工作隐藏起来 等以后恢复现场后继续工作 git stash 查看所有被隐藏的文件列表git stash list 恢复被隐藏的文件，但是内容不删除git stash apply 删除被隐藏文件 git stash drop 恢复文件的同时 也删除文件 git stash pop 查看远程库的信息git remote 查看远程库的详细信息 git remote –v 把master分支推送到远程库对应的远程分支上 git push origin master 把分支推送到远程的分支git push origin develop","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"随笔测试","date":"2017-03-31T07:50:00.000Z","path":"2017/03/31/随笔，杂谈/","text":"随便测试，如果把tags写为随笔，那么就会导航页的随笔中显示，在主题那里的menu可以配置更多的目录。 参考参考这篇文章 http://www.jianshu.com/p/b7886271e21a","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"使用vue2+vue-router+vuex写一个cnode的脚手架","date":"2017-03-29T12:46:00.000Z","path":"2017/03/29/使用vue2+vue-router+vuex写一个cnode的脚手架/","text":"&ensp;&ensp;公司后面的H5项目打算用vue2来做，之前有用过一小会vue，但没有真正的去了解，之前框架来说用react用的比较多点。所以趁这个阶段，用cnode中文网提供的api来做了个入门的脚手架，如果脚手架搭好并理解了，那么后面的运用就轻松多了。 本项目github地址 点击这里 &ensp;&ensp;vue目前在中国来说应该是属于最火的一个前端框架吧，当然，对框架还是一样的态度，如果项目中要用，就去研究它，否则，只需要去了解它。因为之前有react的一些项目经验，而且两者有一些共同性，所以vue的入门来说还是相当比较容易的，主要做的是勤查文档。 &ensp;&ensp;由于时间有限，没有对cnode中文网进行完全的重构，只重构了首页和详情页，因为这样比较容易理解，如果整个重构了，对于初学来说，比较难看懂，完成后的界面如图所示:(没怎么搞样式，界面巨丑) 首页&ensp;&ensp;详情页 项目简介基于vue.js的前端开发环境，用于前后端开发的单页面应用，可以在开发的时候使用ES2015 、scss等。项目包含： 基础库：vue.js、 vue-router2.0版本、vuex、axios 编译/打包工具：webpack、babel、node-sass 单元测试工具：karma、mocha、sinon-chai 本地服务器：express 运行方式 开发环境 npm install 点击start.sh、或者直接cmd里面输入 npm run dev 配置构建项目，构建好的文件会输出到 “dist” 目录， npm run build 服务器，可以查看构建的页面 npm run build-server 单元测试 npm run unit 项目说明&ensp;&ensp;之前玩react比较多，因为在新公司有些项目打算用vue，所以打算也来玩玩vue,不过是直接入手vue2,为了怕自己忘记，所以打算来个小小的总结,不过本文是一篇大杂烩，因为要写vue、vue-router和vuex这三者 vue组件的生命周期&ensp;&ensp;如果你之前有玩过react，那么就可以拿这些生命周期和react的进行一个类比了。组件的生命周期图如下： 如何写一个组件&ensp;&ensp;vue的读音和view同音，和react一样，也是组件化的一个理想框架，vue中组件化是如何实现的呢？我们以我们的项目为例 我们的项目中，首页的列表就有用到组件 indexItem组件,代码如下：component/indexItem.vue 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div class=\"item-list-wrap\"&gt; &lt;ul class=\"item-list\"&gt; &lt;li v-for=\"item in itemList\"&gt; &lt;router-link :to=\"&#123;name:'detail',params:&#123;id:item.id&#125;&#125;\" &gt;&#123;&#123; item.title &#125;&#125;&lt;/router-link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: ['itemList'], mounted: function () &#123; &#125;&#125;&lt;/script&gt;&lt;style lang=\"scss\" rel=\"stylesheet/scss\"&gt;.item-list-wrap&#123; background: #fff; .item-list li&#123; height: 45px; line-height: 45px; text-align: left; padding:0 10px; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space:nowrap; border-bottom: 1px solid #ccc; &#125;&#125;&lt;/style&gt; &ensp;&ensp;我们定义了一个template模板，template数据名称来源于props，所有我们template使用for循环的时候，用的itemList，因为props里面写的是itemList.那么父组件如何调用这些组件呢，使用方法如下：views/index.vue123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;c-header :hTitle=\"title\"&gt;&lt;/c-header&gt; &lt;index-item :item-list='topicsListData'&gt;&lt;/index-item&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import cHeader from 'components/header'; import indexItem from 'components/indexItem'; export default &#123; data () &#123; return &#123; title: 'node中文网', tabId:0 &#125; &#125;, computed: mapGetters(&#123; topicsListData :'getTopicsListData' &#125;), methods: &#123; components: &#123;cHeader,indexItem&#125; &#125;&lt;/script&gt; &ensp;&ensp;如上面的代码所示，我们import我们需要的组件，这里有个注意点，调用组件的时候，不支持驼峰命名法，所以你引用的驼峰命名的组件要拆开，比如引入的是indexItem组件，那么在使用的时候要拆成index-item。 &ensp;&ensp;如何传入数据呢。：[组件props的数据命名]，比如我的indexItem组件中，它的props里面的数据名字为 itemList,所以我父组件传值的时候，也是这样，通过 1&lt;index-item :item-list=传入的数据&gt;&lt;/index-item&gt; &ensp;&ensp;和引入组件一样，如果组件里面的props的命名是驼峰命名方式的话，也是需要拆开的。这里还有个需要注意点，我们不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用。所以我们的项目中，我们应用了什么组件，在compontents里面就要写上对应的组件名称。如代码 1components: &#123;cHeader,indexItem&#125; vur-router 我这边使用的是vue-router2.0版本，遇到了一个坑，就是vue-router跳转之后，再回来，会刷新一次页面。比如我从a页面跳转到b页面，再从b页面返回a页面，那么a页面会刷新一次。这样存在的一个问题就是，我a页面又必须再请求一次数据，或者说，我a页面上传浏览的状态不能够保存。现在还没有找到很好的解决办法，包括使用html5的本地存储也没能很好的解决这个问题。 传参之后，改页面如何获取传过来的参数呢，可以用这个方法，比如我在router中传了一个id到b页面，那么b页面使用的时候可以用下面的代码来获取1this.$route.params.id 关于vue-router就介绍这些，因为可以看文档或者看代码就可以了解完，难度不是很大 vuex2.0&ensp;&ensp;刚开始看了vuex的文档，发觉跟redux很像，因为它确实有参照redux的思想来写，后来在使用过程中，发觉vuex还是跟redux有挺大的不同的。不过两者的一个相同点就是都是属于状态管理器，只有当你的页面有足够多的状态的时候才需要使用，否则没必要用，小项目用vuex之后增加代码的复杂性而已。 这里稍作解释：(个人理解，有误之处，欢迎指出) vuex也是跟redux一样，有且只能由一个store 在vuex中，状态的改变只能是通过mutations 用户改变状态有两种方式：第一种是触发action,然后action再来触发mutations;第二种方式是用户直接出发mutations mutations只能处理同步的状态，而action既能处理同步，也能处理异步,这也是action存在的理由，一般异步的状态管理交给action去做即可，同步的话可以直接触发mutations 触发action用dispatch、触发mutations用commit 这里介绍一下vuex异步的操作&ensp;&ensp;跟redux一样，理解异步状态管理还是比较难的，不过当你理解了异步的操作，你也就基本掌握vuex了。&ensp;&ensp;假设我有一个异步请求，需要请求后台的数据，那么需要怎么做呢？1234567891011121314151617181920212223242526272829303132333435363738import Vue from 'vue';import axios from 'axios';import * as types from '../../constants/constants';const state = &#123; topicsList:[]&#125;;const getters = &#123; getTopicsListData: state =&gt; state.topicsList&#125;;const actions = &#123; /** * @name 获取主页数据 * 异步的操作交给action,然后将获取到的数据 commit 到 mutations那里去 * * # 注意点： * 坑点：vuex2只能有两个参数，所以如果你的第二个参数中有多个参数，可以用对象的形式,实际的项目中貌似通过router中来传的，待定 */ [types.GET_TOPICS](&#123;commit&#125;,obj) &#123; axios.get(`https://cnodejs.org/api/v1/topics?page=$&#123;obj.pageNo&#125;&amp;limit=20&amp;tab=$&#123;obj.tab&#125;`) .then((response) =&gt; &#123; commit(types.SET_TOPICS, &#123; list: response.data.data &#125;) &#125;, (err) =&gt; &#123; console.log(err) &#125;) &#125; &#125;const mutations = &#123; // 获取首页的数据 [types.SET_TOPICS](state,&#123;list&#125;) &#123; state.topicsList=list; //再次记住，mutations是唯一允许更新应用状态的地方 &#125;&#125;;export default&#123; state, getters, actions, mutations&#125; &ensp;&ensp;如上面的代码所示，我们通过axios来发送我们的请求，具体的流程如下： 我们定义了一个默认的状态topicsList，并赋值为一个空数组 我们定义了一个action来获取后端数据， [types.GET_TOPICS]({commit},obj) {},其实这里也可以直接用方法名，只是vuex遵循flux的写法。也就是说这里其实也是可以写成getTopics({commit},obj) {}这种形式的。action的方法里，只能由两个参数，一个是默认的commmit,一个是其他参数，所以当你的异步请求有多个参数的时候，需要把它封装到一个对象或者数组里面。 我们在前面定义了一个默认的装填topicsList,前面也说了，状态的改变只能交给mutations来做，所以action获取到的数据，如果要传到topicsList这个状态中，必须要先交给mutations，再由mutations来更新topicsList。所以，获取到后端返回的数据之后，我们commit给mutations，然后mutations再来更新topicsList这个状态 在上面的代码中，我们有看到getters，干嘛用的呢？有一种情况是这样的，比如我渲染一个页面的时候，页面已经渲染完了，但是你的请求数据是异步的，数据还没有回来，那怎么办呢？getters就是这个作用的。我们将mutations更新的状态，传给getters,在getters里面，你可以对这些数据进行一些处理，然后再交给页面使用。 页面是如何使用传回来的数据的？ 在view/index.vue中，我们看下面的代码，代码是被简化的，只展示出有用的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 &lt;template&gt; &lt;div&gt; &lt;index-item :item-list='topicsListData'&gt;&lt;/index-item&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Vue from 'vue'; import &#123;mapState&#125; from 'vuex'; import &#123;mapGetters&#125; from 'vuex'; import indexItem from 'components/indexItem'; import * as types from '../constants/constants'; export default &#123; data () &#123; return &#123; title: 'node中文网' &#125; &#125;, // computed相当于属性的一个实时计算，里面的数据如果有变化，会自动去更新 computed: mapGetters(&#123; topicsListData :'getTopicsListData' &#125;), methods: &#123; /* * @获取内容 */ getTopics (page,tab,index) &#123; // 触发action this.$store.dispatch(&#123; type:types.GET_TOPICS, pageNo:page, tab:tab &#125;); this.tabId=index; &#125;, &#125;, /* * @初始化(组件挂载完成)，相当于react中的componentWillamount */ mounted () &#123; this.getTopics(1,'all'); &#125;, components: &#123;indexItem&#125; &#125;&lt;/script&gt; &ensp;&ensp;我们可以看到，在代码中，我们定义了一个方法 getTopics，它的作用是发送一个action,并传一些参数进去。页面初始化的时候，我们执行这个方法。也就是mounted里面，我们执行了getTopics这个函数。&ensp;&ensp;我们还看到，代码中，我们在computed里面执行了mapGetters，并在里面写入了getters对象，如代码所示：&ensp;&ensp;123computed: mapGetters(&#123; topicsListData :'getTopicsListData'&#125;), &ensp;&ensp;这里稍作解释，computed的作用就是：它相当于一个实时计算，如果里面的内容对应的数据有变化，就会去自动更新里面的数据，并且重新渲染。而mapGetters是映射对应的getters，代码以键值对的形式： topicsListData :&#39;getTopicsListData &ensp;&ensp;其中指要和getters里面定义的相对应。比如我getter定义的值为getTopicsListData，mapGetters里面对象的值也要写为getTopicsListData。 &ensp;&ensp;而topicsListData则是你需要传到组件中的数据，如下所示 &lt;index-item :item-list=&#39;topicsListData&#39;&gt;&lt;/index-item&gt;; 在异步获取的数据中，如果要传给组件，只能从gettter这里去拿，不然是获取不到后端返回的数据的。因为有一个先后的问题 后记 对于vue2和vue-router2.0以及vuex2的总结就先到这里，主要是自己在第一次使用中遇到的问题。 后面将进入实战阶段，不过脚手架搭好了，后面的问题就是一直参考文档和埋坑就可以了。 当然，因为对vue2的认识时间不是特别长，所以这篇文章难免有些错误，有误之处，欢迎指出","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"http://yoursite.com/tags/vue-router/"}]}]